package com.spark.service;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import com.spark.Entity.UserEntity;
import com.spark.dto.UserDTO;
import com.spark.repository.UserRepository;
import jakarta.transaction.Transactional;

@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepo;
    
    @Autowired
    private PasswordEncoder pwencoder;
    
    // 학생 회원가입
    public ResponseEntity<?> createStudent(UserDTO request) {
        try {
            // ✅ 아이디 중복 검사 추가
            Optional<UserEntity> existingUser = userRepo.findByUserId(request.getUser_id());
            if (existingUser.isPresent()) {
                return ResponseEntity.badRequest().body("이미 존재하는 아이디입니다");
            }
            
            // ✅ 이메일 중복 검사 (기존 방식 유지 가능)
            if (userRepo.existsByEmail(request.getEmail())) {
                return ResponseEntity.badRequest().body("이미 존재하는 이메일입니다");
            }
            
            UserEntity student = new UserEntity();
            student.setUserId(request.getUser_id());
            student.setPw(pwencoder.encode(request.getPw()));
            student.setName(request.getName());
            student.setAddress1(request.getAddress1());
            student.setAddress2(request.getAddress2());
            student.setAddressnum(request.getAddressnum());
            student.setBirthday(request.getBirthday());
            student.setPhone(request.getPhone());
            student.setEmail(request.getEmail());
            student.setPosition("1");  // 학생
            
            userRepo.save(student);
            
            // ✅ JSON 응답으로 변경
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "수강생 회원가입이 완료되었습니다!");
            response.put("userId", student.getUserId());
            response.put("userRole", "STUDENT");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            e.printStackTrace();
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "회원가입 실패: " + e.getMessage());
            return ResponseEntity.status(500).body(response);
        }
    }
    
    // 강사 회원가입
    public ResponseEntity<?> createInstructor(UserDTO request) {
        try {
            // ✅ 아이디 중복 검사 추가
            Optional<UserEntity> existingUser = userRepo.findByUserId(request.getUser_id());
            if (existingUser.isPresent()) {
                return ResponseEntity.badRequest().body("이미 존재하는 아이디입니다");
            }
            
            // ✅ 이메일 중복 검사
            if (userRepo.existsByEmail(request.getEmail())) {
                return ResponseEntity.badRequest().body("이미 존재하는 이메일입니다");
            }
            
            UserEntity teacher = new UserEntity();
            teacher.setUserId(request.getUser_id());
            teacher.setPw(pwencoder.encode(request.getPw()));
            teacher.setName(request.getName());
            teacher.setAddress1(request.getAddress1());
            teacher.setAddress2(request.getAddress2());
            teacher.setAddressnum(request.getAddressnum());
            teacher.setBirthday(request.getBirthday());
            teacher.setPhone(request.getPhone());
            teacher.setEmail(request.getEmail());
            teacher.setPosition("2");  // 강사
            
            userRepo.save(teacher);
            
            // ✅ JSON 응답으로 변경
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "강사 회원가입이 완료되었습니다!");
            response.put("userId", teacher.getUserId());
            response.put("userRole", "INSTRUCTOR");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            e.printStackTrace();
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "회원가입 실패: " + e.getMessage());
            return ResponseEntity.status(500).body(response);
        }
    }
    
    // ✅ 아이디 중복 검사 API 수정 (핵심!)
    public ResponseEntity<?> checkUserIdAvailability(String userId) {
        Map<String, Object> response = new HashMap<>();
        
        try {
            // 🚨 existsByUserId 대신 findByUser_id 사용!
            Optional<UserEntity> existingUser = userRepo.findByUserId(userId);
            boolean available = !existingUser.isPresent();
            
            response.put("available", available);
            response.put("message", available ? "사용 가능한 아이디입니다." : "이미 사용 중인 아이디입니다.");
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            e.printStackTrace();
            response.put("available", false);
            response.put("message", "아이디 확인 중 오류가 발생했습니다.");
            return ResponseEntity.internalServerError().body(response);
        }
    }
    
    // 이메일 중복 검사 API (기존 방식 유지)
    public ResponseEntity<?> checkEmailAvailability(String email) {
        Map<String, Object> response = new HashMap<>();
        
        try {
            boolean available = !userRepo.existsByEmail(email);
            
            response.put("available", available);
            response.put("message", available ? "사용 가능한 이메일입니다." : "이미 사용 중인 이메일입니다.");
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            e.printStackTrace();
            response.put("available", false);
            response.put("message", "이메일 확인 중 오류가 발생했습니다.");
            return ResponseEntity.internalServerError().body(response);
        }
    }
}